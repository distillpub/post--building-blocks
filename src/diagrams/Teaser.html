<div class="container base-grid" style="--img-size: {{img_size}}px;" on:click="set({change_label: null})">
  {{#if ready}}

    <!-- Intro -->
    <div class="intro">
      <div><p>
        Interpretability techniques are normally studied in isolation. But answering questions like, 
        “Why does a model classify this image as a 
        <b>{{left_selected_class_label}}</b>
        rather than a
        <b>{{right_selected_class_label}}</b>?” 
        requires a combination of techniques working together.
      </p></div>
      <div>
        <div class="input_image">
          <img src="examples/input_images/{{$example}}.png" />
          {{#if hover_channel}}
            <Sprite src_class="sprite_mixed4d_activations"
              bg_img="examples/activations/{{$example}}/sprite_mixed4d_activations.png"
              n={{hover_channel}}
              sprite_size={{14}}
              size="{{img_size}}" />
          {{else}}
            <svg viewBox="0 0 14 14" on:mouseleave="set({pos: []})">
              {{#each range(14) as x}}
              {{#each range(14) as y}}
                <rect x="{{x}}" y="{{y}}" width="1" height="1"
                  class="{{(x == pos[0] && y == pos[1]) ? 'selected' : ''}}"
                  on:mouseover="set({pos: [x,y]})"></rect>
              {{/each}}
              {{/each}}
            </svg>
          {{/if}}
        </div>
      </div>
      <div>
        <div style="float: left;">
          <ExamplePicker />
        </div>
        <figcaption>
          By combining feature visualization with class attribution we can see which channels lead to the classsification. 
          In this instance it’s clear that the network is using “ear shape” to distinguish between the two difference animals.
        </figcaption>
      </div>
    </div>

    <!-- Headers -->
    <div class="headers">
      <div>
        <span>Channels that most support</span>
        <select bind:value="left_selected_class">
          {{#each left_classes as c}} 
          <option value="{{c.c}}" disabled={{c.c === right_selected_class}}>{{c.label}}</option>
          {{/each}}
        </select>
        
      </div>
      <div>
        <span>Channels that most support</span>
        <select bind:value="right_selected_class">
          {{#each right_classes as c}}
          <option value="{{c.c}}" disabled={{c.c === left_selected_class}}>{{c.label}}</option>
          {{/each}}
        </select>
      </div>
    </div>

    <!-- Feature Viz -->

    <div class="row_label">Feature Visualization</div>
    <div class="features" on:mouseleave="set({hover_channel: null})">
      {{#each selected_data as d, i}}{{#if d.c}}
          <div class="neuron {{hover_channel === d.c ? 'neuron_hover' : ''}}"
            on:mouseover="set({hover_channel: d.c})" title="Layer mixed4d, Unit {{d.c}}">
            <Sprite src_class="sprite_mixed4d_channel" n={{d.c}} size="110" sprite_size="110" />
          </div>
        {{/if}}{{/each}}
    </div>


    <!-- Evidence -->
    <div class="row_label">Net evidence</div>
    <div class="evidence">
      {{#each selected_data as d, i}}{{#if d.c}}
        <div>value</div>
      {{/if}}{{/each}}
    </div>

    <div class="row_label">for "{{left_selected_class_label}}"</div>
    <div class="evidence">
      {{#each selected_data as d, i}}{{#if d.c}}
        <div>value</div>
      {{/if}}{{/each}}
    </div>

    <div class="row_label">for "{{right_selected_class_label}}"</div>
    <div class="evidence">
      {{#each selected_data as d, i}}{{#if d.c}}
        <div>value</div>
      {{/if}}{{/each}}
    </div>

    <!-- Caption -->

    <p>
      By combining feature visualization with class attribution we can see which channels lead to the classsification. In this
      instance it’s clear that the network is using “ear shape” to distinguish between the two difference animals.
    </p>
  {{else}}
  Loading
  {{/if}}


</div>
<!-- 

  {{#if attr_data && $labels}}
  <div style="grid-column: screen">
    <p class="heading">
      Why does the model think the image is more likely a
      <span class="label" on:click="change_label(event, 0)">{{$labels[selected_classes[0]]}}</span>
      than a
      <span class="label_nv1 label" on:click="change_label(event, 1)">{{$labels[selected_classes[1]]}}</span>?
    </p>

    <div id="change_label" class="nv{{change_label}}"
      style="display: {{change_label === null ? 'none' : 'block'}};
      left: {{change_label_pos.left - 211}}px;">
      <ul>
        <li on:click="set({change_label: null})">{{$labels[selected_classes[change_label]]}}</li>
        {{#each attr_data.classes as c}}
          {{#if c !== selected_classes[0] && c !== selected_classes[1]}}
            <li on:click="select_class(c)">{{$labels[c]}}</li>
          {{/if}}
        {{/each}}
      </ul>
    </div>

    <div style="height: var(--img-size);">
      <div class="subheading">
        <p>Neurons that most support
          <span>{{$labels[selected_classes[0]]}}</span>
        </p>
        <p style="text-align: center;">vs.</p>
        <p>Neurons that most support
          <span>{{$labels[selected_classes[1]]}}</span>
        </p>
      </div>

      <div style="display: flex;" on:mouseleave="set({hover_channel: null})">
        {{#each selected_data as d, i}}
          {{#if d.c}}
            <div class="neuron {{hover_channel === d.c ? 'neuron_hover' : ''}}"
              on:mouseover="set({hover_channel: d.c})" title="Layer mixed4d, Unit {{d.c}}">
              <Sprite src_class="sprite_mixed4d_channel" n={{d.c}} size="110" sprite_size="110" />

              <div class="bar">
                <div class="bar_nv0 bar_filled" style="{{bar_filled(d, 'nv0', i < 3 ? 'nv1' : 'nv0')}}"></div>
                <div class="bar_nv1 bar_filled" style="{{bar_filled(d, 'nv1', i < 3 ? 'nv1' : 'nv0')}}"></div>

                <div class="bar_midpoint"></div>
              </div>

              <div class="outline"></div>
            </div>
          {{else}}
            <div class="neuron" on:mouseover="set({hover_channel: null})"
              style="display: flex; align-items: center; cursor: auto;">...</div>
          {{/if}}
        {{/each}}
      </div>
    </div>
  </div>
  {{/if}}
</div> -->

<style>

  .container {
    margin: 0 20px;
    position: relative;
    --blue: #3497FF;
    --orange: #ff6600;
  }

  .intro {
    grid-column: text/page;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-column-gap: 20px;
  }

  .example_picker { margin-right: 30px; }

   .example_picker img:hover,
   .example_picker img.selected, .example_picker img.selected:hover {
    opacity: 1;
    border-color: goldenrod;
  }

  .input_image {
    width: 100%;
    position: relative;
    margin-right: 30px;
  }

  .input_image img {
    position: absolute;
    top: 0;
    right: 0;
    border-radius: var(--border-radius);
  }

  .input_image .outer {
    position: absolute;
    opacity: 0.8;
    mix-blend-mode: multiply;
    image-rendering: optimizeSpeed;             /* STOP SMOOTHING, GIVE ME SPEED  */
    image-rendering: -moz-crisp-edges;          /* Firefox                        */
    image-rendering: -o-crisp-edges;            /* Opera                          */
    image-rendering: -webkit-optimize-contrast; /* Chrome (and eventually Safari) */
    image-rendering: pixelated; /* Chrome */
    image-rendering: optimize-contrast;         /* CSS3 Proposed                  */
    -ms-interpolation-mode: nearest-neighbor;   /* IE8+                           */
    border-radius: var(--border-radius);
    overflow: hidden;
  }

  .input_image svg {
    position: absolute;
    top: 0;
    right: 0;
  }

  .input_image rect { opacity: 0; }

  .input_image rect.selected {
    opacity: 1;
    fill: rgba(255, 255, 255, 0.5);
    stroke: black;
    stroke-width: 0.01px;
  }

  .row_label {
    font-size: 12px;
    grid-column: kicker;
  }

  .headers {
    grid-column: text/page;
    display: grid;
    grid-template-columns: 1fr 1fr;
  }

  .headers :nth-child(2) {
  }

  .headers span {
    display: block;
  }

  .headers select {
    display: block;
    width: 200px;
  }

  .features {
    grid-column: text/page;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
  }

  .evidence {
    grid-column: text/page;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
  }

  .heading {
    font-size: 90%;
    font-weight: bold;
  }

  .subheading {
    display: flex;
    width: 100%;
    font-style: italic;
  }

  .subheading p {
    flex: 1;
    font-size: 80%;
  }

  .subheading p:last-child {
    margin-left: auto;
    justify-self: flex-end;
    text-align: right;
  }

  .subheading span { text-transform: capitalize; }

  .label {
    color: var(--blue);
    text-transform: capitalize;
    border-bottom: 1px dashed;
    cursor: pointer;
  }

  .label:hover { color: goldenrod; }

  .label_nv1 { color: var(--orange); }

  #change_label {
    position: absolute;
    top: -7px;
    padding: 7px;
    z-index: 100;
    background: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: var(--border-radius);
  }

  #change_label ul {
    margin: 0;
    padding: 0;
    list-style-type: none;
    font-size: 90%;
    text-transform: capitalize;
    cursor: pointer;
  }

  #change_label li:first-child, #change_label li:hover {
    color: goldenrod;
    font-weight: bold;
  }

  #change_label.nv0 { color: var(--blue); }
  #change_label.nv1 { color: var(--orange); }

  .neuron {
    position: relative;
    width: 110px;
    height: 122px;
    justify-content: center;
    cursor: pointer;
  }

  .neuron:nth-child(3), .neuron:nth-child(4), .neuron:last-child { margin-right: 0; }

  .neuron .inner { border-radius: var(--border-radius); }

  .bar {
    position: relative;
    width: 100%;
    height: 12px;
    margin-top: 10px;
    border: 1px solid #aaa;
    box-sizing: border-box;
    border-radius: var(--border-radius);
    overflow: hidden;
  }

  .bar_filled {
    position: absolute;
    top: 0;
    bottom: 0;
    opacity: 0.5;
    /* transition: all 0.5s ease-in-out; */
  }

  .bar_nv0 {
    background-color: var(--blue);
  }

  .bar_nv1 {
    background-color: var(--orange);
  }

  .bar_midpoint {
    position: absolute;
    left: 50%;
    height: 100%;
    border: 1px dashed #666;
    box-sizing: border-box;
  }

  .outline {
    position: absolute;
    top: 0;
    left: 0;
    width: 110px;
    height: 110px;
    box-sizing: border-box;
    border: 5px solid transparent;
    border-radius: var(--border-radius);
  }

  .neuron_hover .outline { border-color: goldenrod; }

</style>

<script>
  import {json as loadJSON} from 'd3-request';
  import {sup} from 'ndarray-ops';

  import {range} from '../util';
  import ExamplePicker from './ExamplePicker.html';
  import Sprite from './Sprite.html';

  const examples = require('../../static/examples').examples;

  export default {
    data() {
      return {
        examples,
        attr_data: {classes: []},
        selected_classes: [],
        pos: [],
        img_size: 165,
        change_label: null,
        loaded: false
      }
    },

    oncreate() {
      this.store.observe('example', (example) => {
        loadJSON(`examples/attributions/${example}/teaser.json`, (err, attr_data) => {
          console.log("loaded", attr_data)
          const selected_classes = attr_data.classes.slice(0, 2);
          this.set({
            loaded: true,
            attr_data, 
            left_selected_class: attr_data.classes[0],
            right_selected_class: attr_data.classes[1]
            // hover_channel: attr_data[`${selected_classes[0]}-${selected_classes[1]}`][0].c
          });
        });

        require(`../../static/examples/npy/${example}_teaser.npy`).load((full_attr) => {
          this.set({full_attr});
        });
      });
    },

    computed: {
      ready(attr_data, $labels, loaded) {
        return loaded && attr_data != null && $labels != null
      },
      labels($labels) {
        return $labels ? $labels : [];
      },
      left_classes(attr_data, labels) {
        return attr_data.classes.map(c => { return {c, label: labels[c]}})
      },
      left_selected_class_label(left_selected_class, labels) {
        return labels[left_selected_class];
      },
      right_selected_class_label(right_selected_class, labels) {
        return labels[right_selected_class];
      },
      right_classes(attr_data, labels) {
        return attr_data.classes.map(c => { return { c, label: labels[c] } })
      },
      selected_classes(left_selected_class, right_selected_class) {
        return [left_selected_class, right_selected_class];
      },
      selected_data(attr_data, selected_classes, pos, full_attr) {
        let data = attr_data[`${selected_classes[0]}-${selected_classes[1]}`];
        if (!data) {
          data = attr_data[`${selected_classes[1]}-${selected_classes[0]}`] || [];
          data = data.slice().reverse();

          if (!pos.length) {
            data = data.map((d) => {
              if (d.nv0) {
                const d2 = Object.assign({}, d);
                const temp = d2.nv0;
                d2.nv0 = d2.nv1;
                d2.nv1 = temp;
                return d2;
              }
              return d;
            });
          }
        }

        if (pos.length) {
          const idx0 = attr_data.classes.indexOf(selected_classes[0]);
          const idx1 = attr_data.classes.indexOf(selected_classes[1]);
          return data.map((d) => {
            const cidx = attr_data.channels.indexOf(d.c);
            return {
              c: d.c,
              nv0: full_attr.get(idx0, pos[1], pos[0], cidx),
              nv1: full_attr.get(idx1, pos[1], pos[0], cidx)
            };
          });
        }

        return data;
      },

      change_label_pos(change_label) {
        const label = document.querySelectorAll('p.heading span.label')[change_label];
        return label ? label.getBoundingClientRect() : {};
      }
    },

    methods: {
      change_label(event, idx) {
        this.set({change_label: idx});
        event.stopPropagation();
      },

      select_class(cls) {
        const change_label = this.get('change_label');
        const selected_classes = this.get('selected_classes');
        selected_classes[change_label] = cls;
        this.set({selected_classes, change_label: null, hover_channel: null});
      }
    },

    helpers: {
      range,

      bar_filled(d, cls, base) {
        const val = d[cls] * 100;
        const width = Math.abs(val) / 2;

        const start = cls === base ? 50 :
          Math.sign(val) === Math.sign(d[base]) ? 50 :
            50 + (Math.abs(d[base] * 100) / 2);

        return ((cls === 'nv0' && val > 0) || (cls === 'nv1' && val < 0)) ?
          `right: ${start}%; width: ${width}%` :
          `left: ${start}%; width: ${width}%`;
      }
    },

    components: {ExamplePicker, Sprite}
  }
</script>
