<:Window on:resize="measure()" />
<div ref:root class="root" style="grid-column: middle">
  <div class="wrapper">
    <div class="headline">
      <h4>Input image</h4>
      <h4>Activations of neuron groups</h4>
    </div>

    <div class="input">
      <ExamplePicker />

      <div style="position: relative;">
        <img src="examples/input_images/{{$example}}.jpeg" alt="{{$example}} input image" style="width: {{imageWidth}}px; height: {{imageWidth}}px;" />
        {{#if hover_group != null}}
          <svg ref:inputOverlay style="box-sizing: border-box; border: 1px solid rgba(0, 0, 0, 0.2); position: absolute; top: 0;" viewBox="0 0 {{10 * spatialActivationsShape[0]}} {{10 * spatialActivationsShape[1]}}">
            {{#each spatialActivations as a}}
            <rect x="{{10 * a.x}}" y="{{10 * a.y}}" width="10" height="10" stroke="black" fill="black" opacity="{{1 - a.groups[hover_group].value / 10}}"></rect>
            {{/each}}
          </svg>
        {{/if}}
      </div>

      <div>
        <svg viewBox="0 0 {{10 * spatialActivationsShape[0]}} {{10 * spatialActivationsShape[1]}}">
          {{#each spatialActivations as a}}
          <rect x="{{10 * a.x}}" y="{{10 * a.y}}" width="10" height="10" fill="{{hover_group != null ? a.groups[hover_group].color : a.color}}"></rect>
          {{/each}}
        </svg>
      </div>
    </div>

    <h4>Neuron groups, based on matrix factorization</h4>
    <div class="colors">
      <div class="label cell">color key</div>
      <div ref:content class="content" on:mouseleave="set({hover_group: null})" style="cursor: pointer;grid-template-columns: repeat({{numColumns}}, 1fr);">
        {{#each groupsData as g}}
          <div class="cell" on:mouseover="set({hover_group: g.i})">
            <div class="legend {{hover_group === g.i ? 'hover' : ''}}" style="background-color: {{g.color}};"></div>
          </div>
        {{/each}}
      </div>
    </div>

    <div class="groups" >
      <div class="label cell">feature visualization</div>
      <div class="content " on:mouseleave="set({hover_group: null})" style="cursor: pointer;grid-template-columns: repeat({{numColumns}}, 1fr);">
        {{#each groupsData as g}}
          <div class="neuron cell {{hover_group === g.i ? 'hover' : ''}}" on:mouseover="set({hover_group: g.i})" style="height: {{neuronWidth}}px;">
            <Sprite bg_img="{{neuron_sprite_url}}" x={{g.i}} sprite_size={{110}} size={{neuronWidth}} />
          </div>
        {{/each}}
      </div>
    </div>

    <h4>Effect of neuron groups on output classes</h4>

    <div class="output" >
      <div class="label">
        {{#each groups.labels as label}}
        <div class="cell">{{$labels[label]}}</div>
        {{/each}}
      </div>

      <div class="content" style="grid-template-columns: repeat({{numColumns}}, 1fr);">
        {{#each groups.attr as attr}}
          <div>
            {{#each attr as a}}
              <div class="cell value">
                {{format(a)}}
                <div class="swatch {{ a > 0 ? 'positive' : 'negative' }}" style="opacity: {{Math.abs(a) * 2}};"></div>
              </div>
            {{/each}}
          </div>
        {{/each}}
      </div>
    </div>
  </div>
</div>


<style>
  .root {
    font-size: 13px;
    line-height: 1.5em;
    max-width: 880px;
    margin: 20px auto;
  }

  .wrapper {
    margin: 0 20px;
  }

  .root h4 {
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding-bottom: 8px;
    margin: 0;
  }

  .root svg rect {
    vector-effect: non-scaling-stroke;
  }

  .example_picker { 
    width: inherit!important; 
  }

  .headline {
    margin-bottom: 8px;
  }

  .input, .headline {
    display: grid;
    grid-gap: 10px;
    grid-template-columns: 120px 1fr 1fr;
  }

  .input {
    margin-bottom: 30px;
  }

 .colors, .groups, .output {
    display: grid;
    grid-gap: 10px;
    grid-template-columns: 120px 1fr;
  }

  .headline :first-child {
    grid-column: 1/3;
  }

  .content {
    display: grid;
    grid-gap: 10px;
    position: relative;
  }

  .content svg {
    width: 100%;
  }

  .input_images {
    position: relative;
    display: grid;
    width: 100%;
    grid-gap: 10px;
  }

  .legend {
    height: 100%;
    border-radius: 4px;
    box-sizing: border-box;
  }

  .legend.hover {
    border: solid 4px rgba(0,0,0,0.3);
  }

  .groups {
    margin-bottom: 30px;
  }

  .neuron {
    position: relative;
    border-radius: 4px;
    overflow: hidden;
  }

  .neuron.hover:after {
    content: "";
    position: absolute;
    top: 6px;
    left: 0;
    width: 100%;
    height: calc(100% - 12px);
    border: 4px solid rgba(0, 0, 0, 0.3);
    box-sizing: border-box;
  }

  .neuron .outer {
    position: absolute;
  }

  .cell {
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    padding: 6px 0;
    position: relative;
  }

  .cell.value {
    text-align: center;
    font-size: 12px;
  }

  .output .swatch {
    text-align: center;
    position: absolute;
    width: 100%;
    height: calc(100% - 10px);
    top: 5px;
    border-radius: 3px;
  }

  .output .swatch.positive {
    background-color: grey;
  }
  .output .swatch.negative {
    background-color: red;
  }

</style>

<script>
  import {range} from '../util';
  import {hcl, mean} from 'd3';
  import ExamplePicker from './ExamplePicker.html';
  import Sprite from './Sprite.html';

  export default {
    data() {
      return {
        stageWidth: 500,
        nmf_data: undefined,
        // collab hooks
        heatmap_sprite: undefined, 
        neuron_sprite: undefined,
        numColumns: 6
      };
    },

    oncreate() {
      // require(`../../static/examples/npy/${example}_teaser.npy`).load((full_attr) => {
      //   this.set({ full_attr });
      // })
      this.store.observe('example', (example) => {
        require(`../../static/examples/npy/${example}_mixed4d_nmf.npy`).load((attr) => {
          this.measure();
          this.set({attr})
          console.log("hey", attr.shape, attr.stride, attr.offset);
        });
      });
    },

    computed: {
      numGroups(spatialActivationsShape) {
        return spatialActivationsShape[2];
      },

      groupsData(numGroups) {
        return range(numGroups).map((groupIndex) => { 
          const hue = (360 / numGroups) * groupIndex;
          return {
            i: groupIndex, 
            hue,
            hueTheta: hue * Math.PI / 180,
            color: hcl(hue, 100, 80).toString()
          };
        });
      },
      spatialActivationsShape(attr) {
        return attr != null ? attr.shape : [0, 0, 0]
      },
      spatialActivations(attr, numGroups, groupsData) {
        const activations = [];
        if (attr) {
          const shape = attr.shape;
          for (let y = 0; y < shape[0]; y++) {
            for (let x = 0; x < shape[1]; x++) {
              const groups = [];
              for (let g = 0; g < shape[2]; g++) {
                const value = attr.get(y, x, g);
                groups.push({
                  x,
                  y,
                  value,
                  hueX: value * value * Math.cos(groupsData[g].hueTheta),
                  hueY: value * value * Math.sin(groupsData[g].hueTheta),
                  color: hcl(groupsData[g].hue, value * 4, value * 3).toString(),
                });
              }

              const meanHueX = mean(groups, h => h.hueX);
              const meanHueY = mean(groups, h => h.hueY);
              const meanHue = Math.atan2(meanHueY, meanHueX) / Math.PI * 180;
              const meanValue = mean(groups, h => h.value) * numGroups / 1.3;
              activations.push({groups, x, y, color: hcl(meanHue, meanValue * 4, meanValue * 3).toString()});
            }
          }
        }
        return activations;
      },

      heatmap_sprite_url ($example, heatmap_sprite) {
        return heatmap_sprite || 
          `examples/activations/${$example}/sprite_mixed4d_nmf_heatmap.png`;
      },

      neuron_sprite_url ($example, neuron_sprite) {
        return neuron_sprite ||
          `examples/activations/${$example}/sprite_mixed4d_nmf_neurons.jpeg`;
      },

      imageWidth: (stageWidth) => (stageWidth - 10) / 2,

      neuronWidth: (stageWidth, numColumns) => (stageWidth - 10 * (numColumns - 1)) / numColumns
    },

    components: {ExamplePicker, Sprite},
    methods: {
      measure: function() {
        this.set({
          stageWidth: this.refs.content.clientWidth
        })
      }
    },
    helpers: {
      range,
      format(v) { return v.toFixed(3); }
    }
  }

</script>